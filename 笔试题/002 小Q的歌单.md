### - 腾讯 18

### 描述

```
    小Q有X首长度为A的不同的歌和Y首长度为B的不同的歌，现在小Q想用这些歌组成一个总长度正好为K的歌单，每首歌最多只能在歌单中出现一次，在不考虑歌单内歌曲的先后顺序的情况下，请问有多少种组成歌单的方法。

输入描述：
    每个输入包含一个测试用例
    每个测试的第一行包含一个整数，表示歌单的总长度K（1<=K<=1000）.
    接下来的一行包含四个正整数，分别表示歌的第一种长度A（A<=10）和数量X（X<=100）以及歌的第二种长度B（B<=10）和数 量Y（Y<=100）.保证A不等于B。

输出描述：
    输出一个整数，表示组成歌单的方法取模。因为答案可能会很大，输出对1000000007取模的结果

输入示例：
    5
    2 3 3 3

输出示例：
    9
```

### 分析1
```
01 背包
当当前所剩的长度>=歌曲i的长度时
  （当有i首歌 剩余长度为j 的方案总数）=不取这首歌的（即有i-1首歌 剩余长度为j的方案总数）+ 取这首歌（即有i-1首歌 剩余长度为j-这首歌长度p[i]的方案总数）
否则（这首歌的长度已经超过歌单剩余长度了）
  （当有i首歌 剩余长度为j 的方案总数）=不取这首歌的（即有i-1首歌 剩余长度为j的方案总数） */
```

```
#include<iostream>
using namespace std;
int B[201][1001]={0};   // B[i][j]，歌单剩余长度为j，用来取i首歌的最多方案数
int w[201];   //w[i] ：第i首歌占用的长度

int main(){
    int k,a,x,b,y,i,j;
    while(cin>>k){
        cin>>a>>x>>b>>y;
        for(i=0;i<=x+y;i++){
            B[i][0]=1;  //B[i][0]都为1，意思是只要歌单长度为0，就算是1种方案。
        }
        
        for(i=1;i<=x;i++){
            w[i]=a;
        }
        for(i=x+1;i<=x+y;i++ ){
            w[i]=b;
        }
        for(i=1;i<=x+y;i++){
            for(j=1;j<=k;j++){
                if(j>=w[i])
                    B[i][j]=(B[i-1][j-w[i]]%1000000007+B[i-1][j]%1000000007)%1000000007;
                else
                    B[i][j]=B[i-1][j];
            }
        }
        cout<<B[x+y][k]<<endl; //B[x+y][k]就是当歌单长度为k，有x+y首歌时的最多方案数
    }
}
```

### 分析2
```
    这道题比较好的处理方法也最容易理解的是用组合数来求解，说到组合数就很容易想到这道题和我们高中做的从两个盒子里取小球的排列组合题。

    此题可以转换为这样一道数学题，有两个盒子，一个盒子里装有3个红球，一个盒子里装有3个白球，红球代表2分，白球代表3分，则从两个盒子中任意拿球使其分数等于9的拿法有多少种。

    这样就会想如果拿了0个红球，白球有多少种拿法，如果拿了1个、2个、3个红球，白球各有多少种拿法。

    再者，将球的数量和球的分数换成未知的量：即有两个盒子，一个盒子里装有X个红球，一个盒子里装有Y个白球，红球代表A分，白球代表B分，则从两个盒子中任意拿球使其分数等于K的拿法有多少种。很显然就和面试题一样了，可以想到假设拿了 i 个红球(i  <= X)，需要满足条件(i * A <= K : 分数不能超过K)&& (( K - i* A）% B == 0 : 确保分数相加等于K) && (( K - i* A）/  B  <= Y :不能超过白球的数目)，将满足条件的结果相加起来就是最后的结果。

    而当满足条件后从各自的盒子里拿球就有不同的拿法，是很典型的排列组合问题，对于这道题我们可以建一个二维数组来存这些组合数，行标代表排列组合公式的下标，列标代表排列组合公式的上标，具体的存法和杨辉三角有些类似，可以直接看代码：
```

```
#include <stdio.h>

long long c[105][105];
const int mod = 1000000007;
 
void init()   //计算组合数
{
    c[0][0] = 1;
    for(int i = 1;i <= 100;i++)
    {
        c[i][0] = 1;
        for(int j = 1;j <= 100;j++)
        c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;
    }
}
 
int main()
{
    int k;                //歌单总长度
    int a;                //长度为a的歌 
    int b;                //长度为b的歌 
    int x;                //长度为a的歌有x首
    int y;                //长度为b的歌有y首
    long long ans = 0;    //组成歌单的种类数
    init();
    scanf("%d",&k);
    scanf("%d%d%d%d",&a,&x,&b,&y);
    for(int i = 0;i <= x;i++)
    {
        if(i * a <= k && (k - i * a) % b == 0 && (k - i * a) / b <= y) //满足题目的判断条件
        {
	        ans = (ans + (c[x][i] * c[y][(k - i * a) / b]) % mod) % mod;
        }
    }
    printf("%lld\n",ans);
    return 0;
}
```

### 参考

https://blog.csdn.net/jmasker/article/details/86842035

https://blog.csdn.net/yue_jijun/article/details/81105030





